<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QR SafeShare - Split secret</title>
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <link rel="apple-touch-icon" href="apple-touch-icon.png">
  <link rel="stylesheet" href="lib/tailwind.min.css">
  <script src="lib/secrets.min.js"></script>
  <script src="lib/qrcode.min.js"></script>
  <script src="lib/jszip.min.js"></script>
  <script src="lib/qrcode3mf.js"></script>
  <script src="lib/bip39-english.js"></script>
</head>
<body class="bg-gray-50 font-sans text-gray-900">

<div class="max-w-5xl mx-auto p-6 space-y-6">

  <!-- Header -->
  <header class="mb-6 text-center flex flex-col items-center gap-2">
    <a href="/" class="flex flex-col items-center hover:opacity-80">
      <img src="logo.svg" alt="QR SafeShare logo" class="w-16 h-16">
      <span class="text-3xl font-bold text-teal-700">QR SafeShare</span>
    </a>
    <p class="text-gray-600">Split passwords and recovery phrases into secure QR codes</p>
  </header>

  <!-- Select type -->
  <section class="bg-white rounded-xl shadow p-6 space-y-4">
    <label class="block text-sm text-gray-600 font-semibold">Choose secret type</label>
    <select id="secretType" class="w-full border rounded p-2">
      <option value="password">Password</option>
      <option value="crypto">Crypto recovery phrase</option>
      <option value="note">Free text</option>
    </select>

    <!-- Password input -->
    <div id="inputPassword" class="mt-3">
      <label class="block text-sm text-gray-600">Password</label>
      <input id="passwordField" type="text" class="w-full border rounded p-2">
    </div>

    <!-- Recovery phrase input -->
    <div id="inputCrypto" class="hidden mt-3 space-y-3">
      <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
        <h4 class="font-semibold text-blue-900 mb-2">Recovery Phrase Input</h4>
        <div class="text-sm text-blue-800 space-y-2">
          <p><strong>What it is:</strong> Your 12 or 24-word backup phrase from wallets like Ledger, MetaMask, or Trust Wallet</p>
          <p><strong>Compatible with:</strong> English BIP39-compliant recovery phrases only</p>
          <p><strong>How to use:</strong> Start typing any word and it will auto-complete. Press Enter or Space to accept and move to the next field</p>
          <p><strong>Why it's better:</strong> Your words get compressed into much smaller QR codes that are perfect for 3D printing</p>
        </div>
      </div>
      
      <p class="text-sm text-gray-600">
        Enter your recovery phrase words below. You can type full words or just the first few letters.
      </p>
      
      <div class="grid grid-cols-2 md:grid-cols-6 gap-2">
        <script>
          for(let i=1;i<=24;i++){
            document.write(`<input id="word${i}" placeholder="${i}" class="border rounded p-2 text-sm word-input" autocomplete="off" spellcheck="false" data-word-index="${i}">`);
          }
        </script>
      </div>
      
      <div class="text-xs text-gray-500 mt-2">
        <p><strong>Security note:</strong> Only enter recovery phrases you want to split for backup purposes. Never share your complete phrase with anyone.</p>
      </div>
    </div>

    <!-- Note input -->
    <div id="inputNote" class="hidden mt-3">
      <label class="block text-sm text-gray-600">Free text</label>
      <textarea id="noteField" rows="5" class="w-full border rounded p-2"></textarea>
    </div>
  </section>

  <!-- Method -->
  <section class="bg-white rounded-xl shadow p-6 space-y-3">
    <label class="block text-sm text-gray-600 font-semibold">Method</label>
    <select id="modeSelect" class="w-full border rounded p-2">
      <option value="shamir">Shamir (n of k)</option>
      <option value="xor">XOR (2 of 2)</option>
    </select>
    <div id="shamirParams" class="flex gap-4 items-end mt-2">
      <div>
        <label class="block text-xs">n (number of shares)</label>
        <input id="nInput" type="number" value="3" min="2" max="5" class="border rounded p-2 w-20">
      </div>
      <div>
        <label class="block text-xs">k (minimum required)</label>
        <input id="kInput" type="number" value="2" min="2" max="5" class="border rounded p-2 w-20">
      </div>
    </div>
    <p id="nkHelp" class="text-xs text-gray-500 mt-2">
      <strong>Explanation:</strong> n = total number of shares. k = minimum number of shares required to reconstruct the secret.
    </p>
    <button id="btnGenerate" class="bg-teal-600 text-white rounded px-4 py-2 w-full mt-4">Generate QR codes</button>

    <!-- Link to combine -->
    <div class="mt-4 p-3 bg-yellow-100 border border-yellow-300 rounded text-sm text-gray-700">
      ‚ö†Ô∏è QR codes created with this tool can only be combined via the 
      <a href="combine.html" class="text-teal-700 underline">Combine</a> page.
    </div>
  </section>

  <!-- Result -->
  <section class="bg-white rounded-xl shadow p-6">
    <h2 class="text-lg font-semibold mb-3">QR shares</h2>
    <div id="sharesGrid" class="grid md:grid-cols-2 gap-4"></div>

    <!-- Donate -->
<div id="bmac-block" class="hidden mt-10">
  <section class="bg-white rounded-xl shadow p-6 text-center">
    <p class="text-gray-700 text-base mb-3">
      üöÄ Enjoying QR SafeShare?<br/>
      Your support helps add new features & keep it free and open source.
    </p>
<a href="https://donate.qrsafeshare.com/" target="_blank" rel="noopener"
   class="inline-flex items-center gap-2 px-6 py-2 
          rounded-full bg-gradient-to-r from-teal-500 to-teal-700
          text-white font-semibold shadow-lg hover:shadow-xl 
          hover:from-teal-600 hover:to-teal-800 
          transition-all duration-200 ease-in-out"
   style="border-radius:9999px; width:auto; display:inline-flex;">
  üöÄ Donate
</a>
  </section>
</div>


  </section>

  <!-- Template -->
  <template id="shareCardTmpl">
    <div class="bg-white rounded-xl shadow p-4 flex flex-col items-center gap-2">
      <div class="label font-semibold"></div>
      <div class="qr border rounded bg-white"></div>
      <div class="grid grid-cols-2 gap-2 w-full">
        <button class="dlBtn bg-teal-600 text-white rounded px-3 py-2">Download</button>
        <button class="dl3mfBtn bg-teal-600 text-white rounded px-3 py-2">3MF export</button>
        <button class="copyQrBtn bg-teal-600 text-white rounded px-3 py-2">Copy QR</button>
        <button class="copyPayloadBtn bg-teal-600 text-white rounded px-3 py-2">Copy payload</button>
      </div>
      <textarea class="payload w-full border rounded p-2 text-xs font-mono" rows="3" readonly></textarea>
    </div>
  </template>

  <!-- Footer -->
<p class="text-xs text-gray-500 text-center mt-8 mb-8">
  ‚ö†Ô∏è Use at your own risk. You are responsible for your secrets. 
  <a href="disclaimer.html" class="underline block mt-1">Read more</a>
</p>
</div>

<script>
const $=sel=>document.querySelector(sel);
function randId(){const u=new Uint32Array(1);crypto.getRandomValues(u);return u[0].toString(16);}
function strToBytes(s){return new TextEncoder().encode(s);}
function bytesToHex(bytes){return Array.from(bytes).map(b=>b.toString(16).padStart(2,'0')).join('');}
function b64uFromBytes(bytes){
  let bin='';bytes.forEach(b=>bin+=String.fromCharCode(b));
  let b64=btoa(bin);
  return b64.replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
}

// BIP39 helper functions - English only for better compression
const BIP39_LANGUAGES = {
  english: typeof BIP39_ENGLISH !== 'undefined' ? BIP39_ENGLISH : null
};

function findWordInList(input, wordlist) {
  const lower = input.toLowerCase().trim();
  
  // Exact match first
  const exactIndex = wordlist.indexOf(lower);
  if (exactIndex !== -1) {
    return { word: lower, index: exactIndex };
  }
  
  // Prefix match
  for (let i = 0; i < wordlist.length; i++) {
    if (wordlist[i].startsWith(lower)) {
      return { word: wordlist[i], index: i };
    }
  }
  
  return null;
}

function detectLanguageAndFindWord(input) {
  // Only English support now
  const wordlist = BIP39_LANGUAGES.english;
  if (!wordlist) return null;
  
  const result = findWordInList(input, wordlist);
  if (result) {
    return { word: result.word, index: result.index };
  }
  
  return null;
}

function wordToIndex(word, wordlist) {
  return wordlist.indexOf(word.toLowerCase());
}

function indexToWord(index, wordlist) {
  return wordlist[index] || null;
}

// Optimized BIP39 compression - English only
function compressBip39Phrase(phrase) {
  const words = phrase.trim().split(/\s+/).filter(w => w.length > 0);
  const indices = [];
  const wordlist = BIP39_LANGUAGES.english;
  
  if (!wordlist) {
    throw new Error('English BIP39 wordlist not loaded');
  }
  
  for (const word of words) {
    const result = detectLanguageAndFindWord(word);
    if (!result) {
      throw new Error(`"${word}" not in BIP39 English wordlist`);
    }
    indices.push(result.index);
  }
  
  // Pack indices into bytes (11 bits per index)
  const bitString = indices.map(i => i.toString(2).padStart(11, '0')).join('');
  const bytes = [];
  
  for (let i = 0; i < bitString.length; i += 8) {
    const byte = bitString.substr(i, 8).padEnd(8, '0');
    bytes.push(parseInt(byte, 2));
  }
  
  // Return optimized data
  return {
    bytes: new Uint8Array(bytes),
    wordCount: words.length
  };
}

// Decompress function 
function decompressBip39Phrase(bytes, language = 'english', wordCount = null) {
  const wordlist = BIP39_LANGUAGES[language] || BIP39_LANGUAGES.english;
  
  // Convert bytes to bit string
  let bitString = '';
  for (const byte of bytes) {
    bitString += byte.toString(2).padStart(8, '0');
  }
  
  // Extract 11-bit indices
  const indices = [];
  const maxIndices = wordCount || Math.floor(bitString.length / 11);
  
  for (let i = 0; i < bitString.length - 10 && indices.length < maxIndices; i += 11) {
    const indexBits = bitString.substr(i, 11);
    const index = parseInt(indexBits, 2);
    if (index < wordlist.length) {
      indices.push(index);
    }
  }
  
  return indices.map(i => indexToWord(i, wordlist)).filter(Boolean).join(' ');
}

// Improved notification system with proper z-index management
function notify(text, type='info'){
  // Remove any existing notifications first to prevent overlap
  const existingNotifications = document.querySelectorAll('.notification-popup');
  existingNotifications.forEach(notification => notification.remove());
  
  const div=document.createElement('div');
  div.textContent=text;
  div.className='notification-popup fixed bottom-4 left-1/2 -translate-x-1/2 text-sm px-3 py-2 rounded-xl shadow-lg z-[9999]';
  
  if(type==='success'){ div.classList.add('bg-green-600','text-white'); }
  else if(type==='error'){ div.classList.add('bg-red-600','text-white'); }
  else { div.classList.add('bg-gray-900','text-white'); }
  
  document.body.appendChild(div);
  setTimeout(()=>div.remove(),2500);
}

// Clamp n/k to 2..5 and disallow 1
function clampNumberInput(el){
  el.addEventListener('input', ()=>{
    let v = el.value.replace(/\D/g,'');
    if(v===''){ return; }
    let n = parseInt(v,10);
    if(n < 2) n = 2;
    if(n === 1) n = 2;
    if(n > 5) n = 5;
    el.value = n;
  });
}

// Toggle inputs
$('#secretType').addEventListener('change',()=>{
  $('#inputPassword').classList.add('hidden');
  $('#inputCrypto').classList.add('hidden');
  $('#inputNote').classList.add('hidden');
  if($('#secretType').value==='password') $('#inputPassword').classList.remove('hidden');
  if($('#secretType').value==='crypto') $('#inputCrypto').classList.remove('hidden');
  if($('#secretType').value==='note') $('#inputNote').classList.remove('hidden');
});

clampNumberInput($('#nInput'));
clampNumberInput($('#kInput'));

// Shamir / XOR toggle
$('#modeSelect').addEventListener('change',()=>{
  const isShamir = ($('#modeSelect').value==='shamir');
  $('#shamirParams').style.display = isShamir ? 'flex' : 'none';
  const nk = $('#nkHelp'); if(nk) nk.style.display = isShamir ? 'block' : 'none';
});

// Generate QRs
$('#btnGenerate').addEventListener('click', async ()=>{
  let secret="";
  let secretBytes = null;
  let compressionInfo = { compressed: false };
  const type=$('#secretType').value;

  if(type==="password"){
    secret=$('#passwordField').value.trim();
    if(!secret){ notify("Enter a password or passphrase","error"); return; }
    secretBytes = strToBytes(secret);
  }
  
  if(type==="crypto"){
    const words=[];
    for(let i=1;i<=24;i++){
      const val=$(`#word${i}`).value.trim();
      if(val) words.push(val);
    }
    if(words.length === 0){ notify("Enter your words","error"); return; }
    
    secret = words.join(" ");
    
    // Try BIP39 compression for smaller payloads, but fallback gracefully
    try {
      if(typeof BIP39_ENGLISH !== 'undefined') {
        const compressed = compressBip39Phrase(secret);
        secretBytes = compressed.bytes;
        
        compressionInfo = {
          compressed: true,
          wordCount: compressed.wordCount
        };
        
        notify(`Compressed ${words.length} words from ${secret.length} chars to ${secretBytes.length} bytes`, 'success');
      } else {
        throw new Error('BIP39 library not loaded');
      }
    } catch (e) {
      // Graceful fallback to plain text - maintains backwards compatibility
      console.warn("BIP39 compression failed, using plain text:", e.message);
      secretBytes = strToBytes(secret);
      compressionInfo = { compressed: false };
      notify(`Using plain text encoding (${secretBytes.length} bytes)`, 'info');
    }
  }
  
  if(type==="note"){
    secret=$('#noteField').value.trim();
    if(!secret){ notify("Enter some text","error"); return; }
    secretBytes = strToBytes(secret);
  }

  const mode=$('#modeSelect').value;
  const grid=$('#sharesGrid'); grid.innerHTML='';

  try{
    if(mode==='shamir'){
      const n=Math.max(2,Math.min(5,parseInt($('#nInput').value||'3',10)));
      const k=Math.max(2,Math.min(n,parseInt($('#kInput').value||'2',10)));

      // If Shamir 2/2 ‚Üí use XOR
      if(n===2 && k===2){
        await runXOR(secretBytes, type, secret, compressionInfo);
        return;
      }

      secrets.init(8);
      const secretHex=bytesToHex(secretBytes);
      const rawShares=secrets.share(secretHex,n,k);
      const id=randId();
      const envelopes=rawShares.map((s,i)=>({
        t:'s',
        c:type,
        n,
        k,
        i:i+1,
        id,
        d:s,
        // Optimized compression metadata for crypto types
        ...(type === 'crypto' && compressionInfo.compressed ? {
          wc: compressionInfo.wordCount
        } : {})
      }));
      await renderShares(envelopes, secret, false);
      notify('Shamir QR codes created','success');
      $('#bmac-block').style.display = "block";
    } else {
      await runXOR(secretBytes, type, secret, compressionInfo);
    }
  }catch(e){ notify('Something went wrong: ' + (e?.message||e),'error'); }
});

async function runXOR(secretBytes, type, originalSecret, compressionInfo = { compressed: false }){
  const S = secretBytes;
  const R=new Uint8Array(S.length); crypto.getRandomValues(R);
  const B=new Uint8Array(S.length); for(let i=0;i<S.length;i++) B[i]=S[i]^R[i];
  const id=randId();
  await renderShares([
    {
      t:'x',
      c:type,
      i:1,
      id,
      d:b64uFromBytes(R),
      // Optimized compression metadata for crypto types
      ...(type === 'crypto' && compressionInfo.compressed ? {
        wc: compressionInfo.wordCount
      } : {})
    },
    {
      t:'x',
      c:type,
      i:2,
      id,
      d:b64uFromBytes(B),
      // Optimized compression metadata for crypto types
      ...(type === 'crypto' && compressionInfo.compressed ? {
        comp: compressionInfo.language,
        wc: compressionInfo.wordCount
      } : {})
    }
  ], originalSecret, true);
  notify('XOR QR codes created','success');
  $('#bmac-block').style.display = "block";
}

// Dynamic QRs + extra block for XOR part 2
async function renderShares(envelopes, secret, isXor){
  const tmpl=$('#shareCardTmpl');
  const grid=$('#sharesGrid');
  
  // Calculate QR size based on payload size (not original secret length)
  const avgPayloadLength = JSON.stringify(envelopes[0]).length;
  let qrSize = 200;
  if(avgPayloadLength > 150) qrSize = 250;
  if(avgPayloadLength > 300) qrSize = 300;
  if(avgPayloadLength > 500) qrSize = 350;

  for(let i=0;i<envelopes.length;i++){
    const env=envelopes[i];
    const node=tmpl.content.firstElementChild.cloneNode(true);
    node.querySelector('.label').textContent = `Share ${String.fromCharCode(65+i)} (#${env.i})`;
    const payload=JSON.stringify(env);

    // Show payload size info
    const sizeInfo = document.createElement('div');
    sizeInfo.className = 'text-xs text-gray-500 mb-2';
    sizeInfo.textContent = `Payload size: ${payload.length} chars`;
    node.querySelector('.label').after(sizeInfo);

    // Render QR code
    const qrContainer=node.querySelector('.qr'); qrContainer.innerHTML='';
    new QRCode(qrContainer,{ 
      text: payload, 
      width: qrSize, 
      height: qrSize, 
      correctLevel: QRCode.CorrectLevel.M 
    });

    // Show payload
    node.querySelector('.payload').value = payload;

    // Download button
    node.querySelector('.dlBtn').addEventListener('click', ()=>{
      setTimeout(()=>{
        const canvas=qrContainer.querySelector('canvas');
        let url=canvas?canvas.toDataURL('image/png'):'';
        if(url){ const a=document.createElement('a'); a.href=url; a.download=`share-${i+1}.png`; a.click(); }
      },150);
    });

    // Copy QR button
    node.querySelector('.copyQrBtn').addEventListener('click', ()=>{
      const canvas=qrContainer.querySelector('canvas');
      if(!canvas) return;
      canvas.toBlob(async (blob)=>{
        try {
          await navigator.clipboard.write([ new ClipboardItem({ 'image/png': blob }) ]);
          notify("QR code copied as image","success");
        } catch {
          notify("Could not copy","error");
        }
      });
    });

    // Extra block only for XOR part 2
    if(isXor && i === 1){
      const url=`${location.origin}/combine.html#${encodeURIComponent(payload)}`;
      const msg = `Here is a special link: this is one of the two codes that together form your secret.\n\nYou will receive the other part as a QR code (for example via email).\n\nOpen the link in your browser to combine the codes:\n${url}`;

      const box=document.createElement('div');
      box.className="mt-3 w-full bg-gray-100 border rounded p-3 text-center text-xs";

      const label=document.createElement('div');
      label.className="mb-2 font-semibold text-gray-700 text-sm";
      label.textContent="Share easily:"; 
      box.appendChild(label);

      // Copy link (with explanatory text)
      const copyBtn=document.createElement('button');
      copyBtn.textContent = "Copy link";
      copyBtn.className = "block w-full mb-2 bg-gray-600 text-white rounded px-3 py-2 text-sm font-semibold";
      copyBtn.addEventListener('click', async ()=>{
        try {
          await navigator.clipboard.writeText(msg);
          notify("Link + explainer copied","success");
        } catch {
          notify("Could not copy","error");
        }
      });
      box.appendChild(copyBtn);

      // WhatsApp button
      const waBtn=document.createElement('a');
      waBtn.href="https://wa.me/?text="+encodeURIComponent(msg);
      waBtn.target="_blank";
      waBtn.className="flex items-center justify-center gap-2 w-full bg-green-600 text-white rounded px-3 py-2 text-sm font-semibold";
      waBtn.innerHTML='<img src="whatsapp.svg" class="w-4 h-4" alt="WhatsApp"> WhatsApp';
      box.appendChild(waBtn);

      node.appendChild(box);
    }

    // Extra handlers for new buttons
    node.querySelector('.dl3mfBtn').addEventListener('click', async()=>{
      const canvas = qrContainer.querySelector('canvas');
      if(canvas){
        const blob = await generate3MF(canvas);
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href=url; a.download=`share-${i+1}.3mf`; a.click();
        URL.revokeObjectURL(url);
      }
    });

    node.querySelector('.copyPayloadBtn').addEventListener('click', async()=>{
      try{
        await navigator.clipboard.writeText(payload);
        notify("Payload copied","success");
      }catch{
        notify("Could not copy","error");
      }
    });

    grid.appendChild(node);
  }
}
  
// Set initial visibility of nkHelp
window.addEventListener('load', ()=>{
  const isShamir = ($('#modeSelect').value==='shamir');
  const nk = $('#nkHelp'); if(nk) nk.style.display = isShamir ? 'block' : 'none';
  
  // Add real-time BIP39 validation with auto-completion
  setupBip39Validation();
});

// Enhanced BIP39 word validation with real-time auto-completion
function setupBip39Validation() {
  const wordInputs = document.querySelectorAll('.word-input');
  
  // Only setup validation if BIP39_ENGLISH is available
  if(typeof BIP39_ENGLISH === 'undefined') {
    console.warn('BIP39_ENGLISH not loaded, skipping validation');
    return;
  }
  
  wordInputs.forEach(input => {
    let autoCompleteTimeout;
    
    input.addEventListener('input', function(e) {
      const value = e.target.value.toLowerCase().trim();
      
      // Clear any existing timeout
      clearTimeout(autoCompleteTimeout);
      
      if (!value) {
        // Empty input - reset styling
        e.target.className = e.target.className.replace(/border-red-300|border-green-300/g, '') + ' border-gray-300';
        e.target.title = '';
        return;
      }
      
      // Check if word exists in BIP39 list
      const result = detectLanguageAndFindWord(value);
      
      if (result) {
        // Valid BIP39 word or valid prefix
        e.target.className = e.target.className.replace(/border-red-300|border-gray-300/g, '') + ' border-green-300';
        e.target.title = `Valid: "${result.word}"`;
        
        // Auto-complete after a short delay if it's a unique prefix
        if (result.word !== value && result.word.startsWith(value)) {
          autoCompleteTimeout = setTimeout(() => {
            if (e.target.value.toLowerCase().trim() === value) {
              const cursorPosition = value.length;
              e.target.value = result.word;
              e.target.setSelectionRange(cursorPosition, result.word.length);
            }
          }, 500); // 0.5 second delay for auto-completion
        }
      } else {
        // Invalid word
        e.target.className = e.target.className.replace(/border-green-300|border-gray-300/g, '') + ' border-red-300';
        e.target.title = `Not found in BIP39 wordlist`;
      }
    });
    
    // Handle tab/enter/space to accept auto-completion and move to next field
    input.addEventListener('keydown', function(e) {
      if (e.key === 'Tab' || e.key === 'Enter' || e.key === ' ') {
        const value = e.target.value.toLowerCase().trim();
        const result = detectLanguageAndFindWord(value);
        
        if (result && result.word !== value && result.word.startsWith(value)) {
          e.target.value = result.word;
          e.target.className = e.target.className.replace(/border-red-300|border-gray-300/g, '') + ' border-green-300';
        }
        
        // Move to next field on Enter or Space (but not Tab - browser handles that)
        if ((e.key === 'Enter' || e.key === ' ') && !e.shiftKey) {
          e.preventDefault();
          const currentIndex = parseInt(e.target.dataset.wordIndex);
          if (currentIndex < 24) {
            const nextInput = document.querySelector(`#word${currentIndex + 1}`);
            if (nextInput) {
              nextInput.focus();
            }
          }
        }
      }
    });
    
    input.addEventListener('blur', function(e) {
      clearTimeout(autoCompleteTimeout);
      const value = e.target.value.toLowerCase().trim();
      if (!value) return;
      
      const result = detectLanguageAndFindWord(value);
      if (result && result.word !== value) {
        // Auto-complete to full word if it's a valid prefix
        e.target.value = result.word;
        e.target.className = e.target.className.replace(/border-red-300|border-gray-300/g, '') + ' border-green-300';
      }
    });
  });
}
</script>
</body>
</html>